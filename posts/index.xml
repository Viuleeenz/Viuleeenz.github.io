<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Security Undisguised</title>
        <link>https://Viuleeenz.github.io/posts/</link>
        <description>Recent content in Posts on Security Undisguised</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Wed, 25 Oct 2023 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://Viuleeenz.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Static analysis on a Vidar sample</title>
            <link>https://Viuleeenz.github.io/posts/2023/10/static-analysis-on-a-vidar-sample/</link>
            <pubDate>Wed, 25 Oct 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/10/static-analysis-on-a-vidar-sample/</guid>
            <description>Behind this post Through this blogpost I’m going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to Cert-Agid in the same period. Even if the payload seems to be out of time, it&amp;rsquo;s still a valid example for further analysis of more recents ones.</description>
            <content type="html"><![CDATA[<h2 id="behind-this-post">Behind this post</h2>
<p>Through this blogpost I’m going to talk about one of the latest Vidar samples that I had a chance to analyze. The payload is actually part of a campaign delivered in July 2023 using PEC mails and this analysis comes from a post related to <a href="https://cert-agid.gov.it/tag/vidar/">Cert-Agid</a> in the same period. Even if the payload seems to be out of time, it&rsquo;s still a valid example for further analysis of more recents ones.</p>
<p>The purpose of this article is to give an overview of Vidar, helping people that are tracking this threat to properly deal with it. Moreover, it is also an excuse <strong>to tweak a little bit with IDA to show a possible solution related to common issues when we are dealing with highly obfuscated malware</strong>.</p>
<h2 id="static-analysis">Static Analysis</h2>
<p>Opening up the Vidar sample with IDA, it’s immediately clear that it contains few obfuscated strings and garbage code that prevents analysts from directly examining the sample. More precisely, it has been possible to discover few functions, analyzed in this blogpost, that are in charge of:</p>
<ul>
<li><strong>Detecting VMs execution</strong>;</li>
<li><strong>Detecting “default settings</strong>”;</li>
<li><strong>Decrypting Strings</strong>.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/RUhAbxUgIAJQKmsvcjyWa6zNEr4ryy9wKguHx0GUVynFje3aEE0pyIF0zkVwVvYnbFOtAeDSuSFFsEImJEkC3leG8DbpwX-QXK5liy-uZfsg1OLFLs2yU8WIOmOSCihExjDcObga9dfCaiJb5sMJ2t0" alt="Figure 1 - Vidar main function with garbage code"></p>
<p>Figure 1 - Vidar main function with garbage code</p>
<h3 id="anti-analysis-implementation">Anti-Analysis implementation</h3>
<p>In this sample, there are three main functions that are in charge of performing anti-analysis checks.</p>
<ul>
<li>The first one is implemented through the function <strong>VirtualAllocExNuma</strong> that checks if the sample is running on a system with one or more physical CPU:</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/-HDWHV34_5kdT04VICJmciGOaRD7ZDMrmP-DmNfc_oftxhumwvommeGnMfWFupVgEo7osoENveFybbs9YHKkQVzyHtXJtkxrnK2jjfceQ6hNTzdi6Bf2peaSK1YlGUFcr2Ma5_fn2KXXGwuAmVSEvCI" alt="Figure 2 - Call to VirtualAllocExNuma for physical CPU controls."></p>
<p>Figure 2 - Call to VirtualAllocExNuma for physical CPU controls.</p>
<ul>
<li>Another techniques to prevent payload execution is related to <strong>the number of processors available on the machine that are required to be at least 2</strong>:</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/o9yejv6GNkWp4yTsJWF_PSOyxKHco5lfkCMLLGbIkkyVhKHHkWiJtv4JCppNsQZs0BBSBvuvFsInQg-4nrqrBH6_dzl65lzyV1cSeSWGzy2I0nRmkr6EK9CYRq3L_-g2V9RQQaOztA8bXIBfJN-WMZk" alt="Figure 3 - Call to GetSystemInfo for Processors’s checks"></p>
<p>Figure 3 - Call to GetSystemInfo for Processors’s checks</p>
<ul>
<li>The last checks that have been identified are related to the Username and Computer Name that is currently used. In particular there are two matches that verify if the username corresponds to <strong>John Doe</strong> and then the <strong>ComputerName</strong> is equal to <strong>HAL9TH</strong>.</li>
</ul>
<blockquote>
<p>It turns out that Microsoft Defender&rsquo;s Sandbox computername is HAL9TH, so, you can check for the computer name in your malware before detonation, if the name matches HAL9TH, it means you&rsquo;re inside defender&rsquo;s sandbox, so you can make your program exit.</p>
</blockquote>
<p><img src="https://lh7-us.googleusercontent.com/Jlr2e4g6gpjrrFi1uxvrWJZ2usZnGZR_smo3v1PEviMjw8kspy4PL0pm0kMozeRVi3I988gpt0tEvGmHN58pfFXHaw0m_i22FgHhcMnNixAfh-onZBxHmES16D6ZltkhiyEaWdLd7WFuFmLVQwRDZqQ" alt="Figure 4 - Checking for “specific settings”"></p>
<p>Figure 4 - Checking for “specific settings”</p>
<p>If one of those checks fails, the payload will call the function <strong>ExitProcess(0)</strong> terminating its execution.</p>
<h3 id="decryption-routine">Decryption routine</h3>
<p>As already mentioned, Vidar payload contains few encrypted strings to slow down the analysis and probably to evade few monitoring solutions. Because of that, there is a function that is in charge to retrieve the plaintext associated with each encrypted string.</p>
<p><img src="https://lh7-us.googleusercontent.com/O34JU_qxsazBuGRm4zbwGM8YimF1fGb1ppOvjoy_Freuwe95fHNFwWn-iaF28q__xg92YpjDPylvOZIeP0CvICtdoG7iYI5hyd5786JE4PXDgc8AwYOzLCpZq7lcY5w2MgXeMfuPSzdDTjrBLACNM00" alt="Figure 5 - Encrypted Strings"></p>
<p>Figure 5 - Encrypted Strings</p>
<p>The function it&rsquo;s fairly easy to spot especially observing the number of times it will be called and its signature (that recall a quite simple decryption procedure):</p>
<ul>
<li><strong>decryption_routine</strong>(encrypted_string , key , length)</li>
</ul>
<p>As expected the decryption routine it&rsquo;s not so hard to understand, in fact it iterates over the key length and performs an <strong>XOR</strong> operation between the <strong>encrypted_string</strong> and <strong>key</strong> parameters.</p>
<p><img src="https://lh7-us.googleusercontent.com/nEm9g0DmlIQNnO4HVGmAokxfV_MiWn1pgAX-XD3ut6Gy2nSIGY_IdTWmAVwb7iZVIMonhgdwGwqb1pxank2vEqReC50L5LnYPOfwlW7UrOzM5LiQ-3b67KZfgGEWcKuGNUYFgjErruihN5D0S0p6-VY" alt="Figure 6 - Decryption routine"></p>
<p>Figure 6 - Decryption routine</p>
<p>Now that we have understood how the decryption routine works, it&rsquo;s possible to speed up our analysis by writing an <a href="https://viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/">IDA-python</a> script that takes care of those strings.</p>
<p><img src="https://lh7-us.googleusercontent.com/ztZ7Z6oxeCfGDB_ki1WvSAF-jChkBAyv00n-W0W3cfdjUzbuIeNMA4Y3TfatAuXwrZa07em1ps2j_47P3n5cdfaMiTGvG5hOSMx2sVe-R_IrkXl62zeTxT7FL4NLtAT7mlWq37cxgKKadxjxow1_nRE" alt="Figure 7 - String decrypted"></p>
<p>Figure 7 - String decrypted</p>
<p>It’s worth noting that IDA has few limitations, in fact sometimes it does not perform the proper variable renaming and due to the obfuscation implemented few instructions could be misinterpreted. Because of that an effective method to <strong>keep track of decrypted variables is to locate their offset and append a comment</strong>. In that case, we should have a nice reference that could be used later on to rename the variable accordingly.</p>
<h3 id="fixing-functions">Fixing Functions</h3>
<p>As mentioned above, IDA sometimes could be confused by obfuscation that could lead to mis-interpret instructions or inhibit its ability to recognize a function. In fact, <strong>at the end of main</strong> there is a jump to a location that is not currently interpreted as a function. However, looking at strings and references to that text section there clearly is an error from the IDA interpreter.</p>
<p><img src="https://lh7-us.googleusercontent.com/_i129YO91RRHlKrIIzaqJSO77K63-3EjGKLWqMSwkXw96T_mWeO5lvgEC8RkFi8mpGQvtgaVhwgNbr3z__vbm3cZws9y4jgwq-qXoHt72h5gvEyxMRlszrabva2jI8e4nYMCn-n8vFvvrMfdRLXrqNw" alt="Figure 8 - Mis-intepreted function"></p>
<p>Figure 8 - Mis-intepreted function</p>
<p>To fix that, it’s possible to select the block of code and force IDA to treat that as a function. However, this practice it’s not always painless. In fact, it&rsquo;s still possible that we could get some issues from IDA that are not capable of interpreting all code correctly. An example is given from the figure below, where we have strings related to <strong>JUMPOUT</strong> and <strong>MEMORY</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/9E5IDw_OiMauChtO3a8kmYcvag0cD-w8srPJduXSg_8niBztLjuwgX10a7wKUUCOgAmBSCaDdO4l8xqxGVsmjrifWZL-CeeHJiGoHb7zlZo8rREHqIihxtikMgHtUAV3VTz77mQ7VixYwiO5xJ-_UI0" alt="Figure 9 - Function interpreted as data"></p>
<p>Figure 9 - Function interpreted as data</p>
<p>This issue could be solved easily by fixing the byte related to the <strong>JUMPOUT</strong> instruction, however, in order to avoid losing focus on our main tasks, this issue will probably be discussed in a dedicated thread.</p>
<p>Nevertheless, we have now all pieces to complete our static analysis and go deep in all malicious activities related to this malware.</p>
<h2 id="additional-analysis">Additional Analysis</h2>
<p>String decryption was an effective method to extract IOCs from this Vidar sample. As expected, it works as an InfoStealer, querying browser information (credentials on local storage) and multiple installed programs. At the time of writing, it supports most of the main used browsers, such as: Chrome, Firefox, Opera, Tor, etc.</p>
<p>Another interesting feature is related to the <strong>chrome extension</strong> checks feature, that aims to verify if specific extensions are actually installed. Mainly monitored extensions are related to <strong>crypto wallets</strong> and <strong>password managers</strong>.</p>
<p><img src="https://lh7-us.googleusercontent.com/aV7S2p8iQiUzjzkHNTFC0HLUbA1mJ7_gLJNYHEh_pmrpA39UtlOQEHpxUzdPLeMqPz6KX-tWZSGb7csNwhzTsXXiInuIO_cC29ZtN-Q3cmhRQ2qqKVwGUXJUHI6LUxc8eFGAdrBxl0lBTbfO8Yummd8" alt="Figure 10 - Monitored chrome extensions"></p>
<p>Figure 10 - Monitored chrome extensions</p>
<h2 id="network-communication">Network Communication</h2>
<p>According to the examined functions related to the network communication, it is possible to recreate the POST request structure that could be monitored and used as an indicator of compromise of this actor:</p>
<p>Content Disposition: form-data; name=&lt;Vidar_parameter&gt;</p>
<p>It’s worth mentioning that parameters observed are:</p>
<ul>
<li><strong>ID</strong> for BOT identification;</li>
<li><strong>HWID</strong> that uniquely identifies a machine (used for monitoring multiple infection from the same machine, indicating an analyzing attempts from researcher);</li>
<li><strong>Token:</strong> Exfiltrated token available on the victim’ machine;</li>
<li><strong>File:</strong> An archive of all information gathered from the victim’s machine.</li>
</ul>
<p><img src="https://lh7-us.googleusercontent.com/yIAa0snonhSg0z1Th0EeZMkPMap6PnuZ3tueBAOL5KLjHWFMLc3150BY7KGaaCftMjiSg1IgEMYQmdCO8RwbTCV6d7gcNsMvph6KaWLLP54RtLpvsCTeORzZeY6QwCfpnrthNtTEkfiYf6gOGt_qBso" alt="Figure 11 - POST request structure"></p>
<p>Figure 11 - POST request structure</p>
<h2 id="references">References</h2>
<p>Sample:</p>
<ul>
<li>556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456 (SHA256)<a href="https://bazaar.abuse.ch/sample/556f8b06b92ddbc4008dea5298eab3934c61647a1cd7333a9087c37cc5a75456/">MalwareBazaar</a></li>
</ul>
<p>Microsoft Defender&rsquo;s Sandbox:</p>
<ul>
<li>BlackHat 2018 <a href="https://i.blackhat.com/us-18/Thu-August-9/us-18-Bulazel-Windows-Offender-Reverse-Engineering-Windows-Defenders-Antivirus-Emulator.pdf">detailed analysis </a></li>
</ul>
<h2 id="iocs">IOCs</h2>
<ul>
<li>
<p>Network indicators</p>
<ul>
<li>https://t.]me/game4serv</li>
<li>https://steamcommunity.]com/profiles/76561199523054520</li>
<li>http://bigsnowstone.]com/</li>
</ul>
</li>
<li>
<p>Targets</p>
<table>
<thead>
<tr>
<th>Browsers</th>
<th>Browser Extensions - Wallets</th>
<th>Authenticator/Password Manager</th>
<th>Desktop Programs</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mozilla Firefox</td>
<td>TronLink</td>
<td>Authenticator</td>
<td>LevelDB</td>
</tr>
<tr>
<td>Pale Moon</td>
<td>Meta</td>
<td>Authy</td>
<td>Thunderbird</td>
</tr>
<tr>
<td>Google Chrome</td>
<td>BinanceChainWallet</td>
<td>EOS Authenticator</td>
<td>Telegram</td>
</tr>
<tr>
<td>Chromium</td>
<td>Yoroi</td>
<td>GAuth Authenticator</td>
<td>WinSCP</td>
</tr>
<tr>
<td>Amigo</td>
<td>NiftyWallet</td>
<td></td>
<td>IndexedDB</td>
</tr>
<tr>
<td>Torch</td>
<td>MathWallet</td>
<td></td>
<td>Steam</td>
</tr>
<tr>
<td>Comodo Dragon</td>
<td>Coinbase</td>
<td></td>
<td>Jaxx_Desktop</td>
</tr>
<tr>
<td>Epic Privacy Browser</td>
<td>Guarda</td>
<td></td>
<td>Binance Desktop</td>
</tr>
<tr>
<td>Vivaldi</td>
<td>EQUALWallet</td>
<td></td>
<td>Bitcoin Core</td>
</tr>
<tr>
<td>CocCoc</td>
<td>JaxxLiberty</td>
<td></td>
<td>Bitcoin Core Old</td>
</tr>
<tr>
<td>Cent Browser</td>
<td>BitAppWallet</td>
<td></td>
<td>Raven Core</td>
</tr>
<tr>
<td>TorBro Browser</td>
<td>iWallet</td>
<td></td>
<td>Ledger Live</td>
</tr>
<tr>
<td>Chedot Browser</td>
<td>Wombat</td>
<td></td>
<td>Blockstream</td>
</tr>
<tr>
<td>Brave_Old</td>
<td>MewCx</td>
<td></td>
<td></td>
</tr>
<tr>
<td>7Star</td>
<td>GuildWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Microsoft Edge</td>
<td>RoninWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>360 Browser</td>
<td>NeoLine</td>
<td></td>
<td></td>
</tr>
<tr>
<td>QQBrowser</td>
<td>CloverWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Opera</td>
<td>LiqualityWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td>OperaGX</td>
<td>Terra_Station</td>
<td></td>
<td></td>
</tr>
<tr>
<td>CryptoTab Browser</td>
<td>Keplr</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Brave</td>
<td>Sollet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>AuroWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>PolymeshWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>ICONex</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Harmony</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>EVER Wallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>KardiaChain</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Trezor Password Manager</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Rabby</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Phantom</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BraveWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>PaliWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>BoltX</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Xdefi</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Nami</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>MaiarDeFiWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>WavesKeeper</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Solflare</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>CyanoWallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>KHC</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>TezBox</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Temple</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Goby</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>RoninWalletEdge</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Wasabi Wallet</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>Daedalus Mainnet</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Agent Tesla - Building an effective decryptor</title>
            <link>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</link>
            <pubDate>Tue, 29 Aug 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/08/agent-tesla-building-an-effective-decryptor/</guid>
            <description>General Information and preface Agent Tesla, according to the data provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted.</description>
            <content type="html"><![CDATA[<h1 id="general-information-and-preface">General Information and preface</h1>
<p>Agent Tesla, according to the <a href="https://cert.europa.eu/static/threat-intelligence/TLP-CLEAR-CB-23-08.pdf">data</a> provided by CERT-EU, is one the most prominent threats that are hitting European cyberspace. Because of that, I found that it could be quite interesting understanding its behavior. However, as I usually prefer, instead of focusing on the infection chain or information about TA methodologies, sharing knowledge that were already provided by more authoritative sources, I preferred to focus mostly on malware analysis and in this specific case to the latest encryption algorithm adopted. Then, upon the knowledge acquired, I would like to write a decryptor script that extracts payload configuration.</p>
<h1 id="encryption-variants">Encryption variants</h1>
<p>Agent Tesla first appeared in 2014, however, its evolution over time could be tracked by multiple TTPs. For the purpose of this article, I’m versioning it through the encryption algorithm adopted. At the time of writing there have been 4 different versions with unique characteristics:</p>
<p><strong>Encryption v1</strong>: Through this encryption implementation, strings are stored (encrypted) in base64. The decryption function uses a password and a salt ( both hardcoded) as input for the SHA1 algorithm, in order to generate the decryption key. Then, ciphertext and key are eventually used with AES in CBC mode.</p>
<p><strong>Encryption v2</strong>: The main difference from the previous method, is that each encrypted string is paired with a dedicated key and an IV. The algorithm used is still AES in CBC mode.</p>
<p><strong>Encryption v3</strong>: In this version, TA completely changed their approach, shifting to a pure <em>xor decryption</em>. The decryption function is defined within the <em>.cctor()</em> constructor. The structure of encrypted strings is quite simple. Each string is contained in a byte array paired with a key. The size of the ciphertext allows the decryption routine to iterate over the byte array distinguishing all parameters.</p>
<p><strong>Encryption v4</strong>: The latest version of Agent Tesla is based on a <em>xor string</em> algorithm that stores information within a macro-structure that contains raw data organized as follow:</p>
<p><img src="https://lh4.googleusercontent.com/rgMJHsQLR6JB0OjAGzCeIZGYJAEiuThnX5uPyZPB9ukmC7vPMclavaVnoQgB9G3tRnv8IOZ2Lvjbcav4pjEUS1uxqeF8fktYlITE4YsNZ9yLtgZJsmsQjCzjKvLfKA0oKT6hzNNZNWE3COKWp0Smm9k" alt="Figure 1: Encrypted data structure"></p>
<p>Figure 1 - Encrypted data structure</p>
<p>In this version we have a macro-struct that contains the encrypted data. It’s actually possible to visualize it as an array where each element follows a specific structure where the first 4 bytes are dedicated to define the encryption data length, then other 4 bytes are used to describe the encryption key and the remaining bytes are reserved for the actual data.</p>
<p>As always, the decryption routine iterates over the encrypted data, using key bytes.</p>
<h1 id="analysis-of-encryption-v4-and-obfuscation-routine">Analysis of encryption v4 and obfuscation routine</h1>
<p>As I wrote in the first paragraph Agent Tesla analysis will be carried out on the latest encryption mechanism. Because of that, let’s start analyzing the main components of this algorithm:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C#" data-lang="C#"><span style="display:flex;"><span><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">byte</span>[] RXOR(<span style="color:#66d9ef">byte</span>[] data, <span style="color:#66d9ef">out</span> <span style="color:#66d9ef">int</span> key)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>key = RandomNumberGenerator.GetInt32(<span style="color:#66d9ef">int</span>.MaxValue);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// RXOR Cipher: reverse array order and decrypt byte by byte using single XOR</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n = data.Length - <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; n; i++, n--)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>data[n] ^= (<span style="color:#66d9ef">byte</span>) (data[i] ^ key);
</span></span><span style="display:flex;"><span>data[i] ^= data[n];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (data.Length % <span style="color:#ae81ff">2</span> != <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>data[data.Length &gt;&gt; <span style="color:#ae81ff">1</span>] ^= (<span style="color:#66d9ef">byte</span>) key; <span style="color:#75715e">// x &gt;&gt; 1 == x / 2</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">return</span> data;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The key is generated randomly through <strong>RandomNumberGenerator.GetInt32(int.MaxValue)</strong> function. The <em>int.MaxValue</em> constraint is related to the key size limitation of 4 bytes within the encrypted data structure. The algorithm it&rsquo;s pretty straightforward, performing <em>xor</em> between plaintext and key bytes. However, what really matters here is the <strong>obfuscator</strong> that happens at runtime.</p>
<p>The <strong>obfuscation routine</strong> is part of an open source <a href="https://github.com/dr4k0nia/XorStringsNET">project</a>. Basically, this obfuscation works creating multiple placeholders that are going to be replaced at runtime. Analyzing the sample statically, this technique messes up with code decompilers such as DnSpy. However, the author wrote a detailed <a href="https://dr4k0nia.github.io/posts/Encrypting-Strings-In-NET/">blogpost</a> explaining obfuscator features and its modus operandi:</p>
<blockquote>
<p>&ldquo;After processing all methods we need to do some patches in the injected runtime. First, we need to set up the placeholder struct with the correct attribute values. The struct needs a <strong>ClassLayout</strong> with <strong>packing size 1</strong> and the <strong>length of the encrypted data as its size</strong>.&rdquo;</p>
</blockquote>
<blockquote>
<p>&ldquo;We also need to create a new <strong>field which will be an initialized version of our struct</strong>. By adding a DataSegment in its <strong>FieldRva</strong>, we can use the field to store any raw data we want, in this case, our encrypted string data.&rdquo;</p>
</blockquote>
<p>Following the indication provided by the author, we should have a more clear idea of what these components are and how to hunt for them in the code. Now it’s possible to start looking at the code gathering as much information as possible (e.g., locating these placeholders) and finding out a pattern to write an effective configuration decryptor.</p>
<h1 id="binary-inspection">Binary inspection</h1>
<p>If we open up DnSpy, we could be overwhelmed by the mess that is going to be presented in front of us. However, trying to follow the code flow, we could start exploring.</p>
<p><img src="https://lh5.googleusercontent.com/zuONKbBX5bsAJ-9VLBUlNoqYkhrk3PdCdn3WHkNawFSZG6MvRT636ILfvDcipjFTT0GlhrCzBdbnxiDNMWsQpDpViMBIgFZFJZ1fhqZZJZdi_bi3lRoGkMNJ2pv16lful5B_TWsxw7m6nMatFOupgRw" alt="Figure 2: Entry point"></p>
<p>Figure 2 - Entry point</p>
<p>Starting from the Entry Point, it’s possible to locate something promising. Exploring variable and function calls and following references to the object <strong>GWZl2RFJ6nA</strong>, it&rsquo;s possible to bump into quite interesting piece of code.</p>
<p><img src="https://lh4.googleusercontent.com/U3w0tnCvmRyhyBt97-Pk36cwOrTPTGa6KoRQIWPwArHkdyJ8nwQZWrchT7r4dQiU7BbazIGGDoDYDl1wPIknrnyjdzR1ZZo4jC-mLGlcbqllKjfDRnBR8UdJOAU7UlPiHWo4Uzd48Hj-AY0tSpXuG48" alt="Figure 3: Obfuscated decryption routine"></p>
<p>Figure 3 - Obfuscated decryption routine</p>
<p>First of all, we see the function <strong>cpblk</strong> that it’s necessary to perform the injection at runtime, moreover, scrolling the code it&rsquo;s possible to get insight about pointer operations paired with xor. In fact, observing the line 104 in Figure 3, it is very similar to the encryption routine that we saw in the previous paragraph.  Nevertheless, on the top of that, as a final proof that we are looking in the right place, scrolling at the end of the code we see a class that fulfills all requirements requested by the obfuscator.</p>
<ul>
<li><strong>ClassLayout</strong></li>
<li><strong>Pack size = 1</strong></li>
<li><strong>Size = encrypted data length</strong></li>
</ul>
<p><img src="https://lh4.googleusercontent.com/SscVl6FW0XbBVt3px_oGIjxBChRw68fi7Zrez6Mumu_WF7sdJBsNRMVqrIqaXeIo-mPaMQf0V8VnILZKPbprhbATjKxIjhWxLwULyM9FngDrwEdjA2C09QVdog2oUeMjqfngeFViG5m6TJrDQqb37wA" alt="Figure 4 - Class placeholder for runtime decryption"></p>
<p>Figure 4 - Class placeholder for runtime decryption</p>
<p>Moreover, following the instruction provided by the author, we should be able to locate the encrypted string in raw bytes within the binary. If we have a closer look to struct <strong>zqRrwrwgu</strong> examining the raw value, we are redirected to a very suspicious sequence of bytes.</p>
<p><img src="https://lh3.googleusercontent.com/SGwLKd7RiZ-or8mXHPy7frC_MDAQgyn3RcHZ9sK_vs3jU_yReO3wmC_4le_AFu-l8jxsvGEF2Li5sgbNIa5ObmTDEjkJysNMQUrbwfhkGkESbwRg_gApWFALZmnSVnIyFpe412KCqGRwGy2ryp3H63o" alt="figure 5 - Encrypted String"></p>
<p>Figure 5 - Encrypted string</p>
<p>Analyzing those bytes, it&rsquo;s immediate to find out that we are dealing with an encrypted payload that is ready to be decrypted.</p>
<h1 id="decrypting-strings">Decrypting Strings</h1>
<p><strong>The idea behind this script is simple</strong>:</p>
<ul>
<li>Find out a class that is big enough to contain the encrypted data ( usually the biggest class in the code). Then we could retrieve raw bytes related to its size from the binary file and forward them towards our decryption routine</li>
</ul>
<p>Before proceeding, it&rsquo;s worth mentioning that I’m quite a newbie in .NET interaction with python and generally, I’m still learning .NET layout. Because of that, if someone else is going to produce more efficient code. Please do it! But for now, let’s do a quick look to this this script:</p>
<p><img src="https://lh6.googleusercontent.com/YgvfXQ1w_ggTUJ8u7Gd0oP5hPymmMYsmLFFVX0FmNoNx9oYpJ6ALMGdINsjWlQ3b25nzLXobQmcMt0-TmyWwVClZ28nHmJbO4Jmw92ck25uN-2A5XwGmtwx1EoTFYSugv8RD9JN9hn8liM6dALueaTY" alt="Figure 6 - Agent Tesla decryptor"></p>
<p>Figure 6 - Agent Tesla decryptor</p>
<ul>
<li><strong>Line 40 - 44:</strong> Gathered references to ClassLayout and FieldRVA Tables.</li>
<li><strong>Line 46 - 47:</strong> Following the initial idea that encrypted data should be stored in a quite large class, I started to enumerate class, selecting the biggest (likely the one that contains the encrypted strings)</li>
<li><strong>Line 51:</strong> retrieve the last element of the FieldRVA table that contains our data (I don’t know if it is an unexpected behavior caused by the obfuscation process applied, but the raw data containing the encryption string resulted to be always the last element of the FieldRVA table).</li>
</ul>
<p>Running our script on one of the latest Agent Tesla sample, we got the following result:</p>
<p><img src="https://lh3.googleusercontent.com/MtQZbbAOaz2HR4EEGvuVnAH2VoTzbz3P31VeZe0WPg_qMGpPuDOOQH7vn5jxriHiljyrfpK_3T_lejGWJ3Scwq1vNJDICyjvmkhZzI8g423d7e20_R8XSulLtXB9Db_-Si7wu5H6dPT95HPotd-BY7o" alt="Figure 7 - Decryptor result"></p>
<p>Figure 7 - Decryptor result</p>
<h1 id="references">References</h1>
<p>Agent Tesla Decryptor:</p>
<ul>
<li><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/ConfigurationExtractors/AgentTesla/agent_tesla_decryptor_v4.py">agent_tesla_decryptor_v4.py</a></li>
</ul>
<p>DotNet references:</p>
<ul>
<li>General .NET implementation <a href="https://www.ntcore.com/files/dotnetformat.htm">info</a></li>
<li>Python <a href="https://github.com/pan-unit42/dotnetfile">parser</a> for .NET</li>
</ul>
<p>Samples:</p>
<ul>
<li>ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3 (SHA256) <a href="https://bazaar.abuse.ch/sample/ae26382f191225447550e9a691453fc3ea2e02127222787c662efc8db63c59e3/">MalwareBazaar</a></li>
<li>acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a (SHA256) <a href="https://bazaar.abuse.ch/sample/acedd97c8350bacc485e87ae56c851d08b497c202deb46df28c3e7218cb4469a/">MalwareBazaar</a></li>
<li>f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8 (SHA256)<a href="https://bazaar.abuse.ch/sample/f5751d89bc6f15c3ade6513d3cf44f92a25e8cd25d2f5ad239b8c44f8f732cb8">MalwareBazaar</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>IDA-Python - Locate a function independently from its offset</title>
            <link>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</link>
            <pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-a-function-independently-from-its-offset/</guid>
            <description>Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.</p>
<p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis <strong>without tweaking specific parameters</strong> making it <strong>independent from the function offset</strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts.</p>
<p>Generally speaking, approaching to these sample could be done through multiple perspective (e.g., starting with dynamic analysis and proceeding backwards), however, for the purpose of this blogpost I’m going to take a custom sample written by me, where strings are partially obfuscated with custom algorithm and I’m going to show an easy but effective method to write an ida-python script to <strong>locate and deobfuscate variables</strong>.</p>
<h2 id="practical-example">Practical example</h2>
<p>First go first. In order to deobfuscate a piece of code, it&rsquo;s still required to analyze the function that is going to perform this task and replicate its behavior implementing it within our script. For the purpose of this post, this step is out of scope, however, I’m going to directly analyze the assembly code in order to find out how to write the IDA-python script to collect all obfuscated variables to apply the proper routine.</p>
<p>The steps that we are going are pretty much the following:</p>
<ul>
<li>Find out the deobfuscation function;</li>
<li>Create a “signature” to retrieve all its references;</li>
<li>Collect the obfuscated parameters;</li>
<li>Apply the deobfuscation routine;</li>
</ul>
<h2 id="creating-function-signature">Creating function signature</h2>
<p>Since that sample it&rsquo;s actually very easy, finding the proper function it’s not so tricky. In fact, we could see that there is a DWORD that is going to be passed to a function called “<strong>DeobfuscateString</strong>”. However, what really matters here, is to create a signature of this function in order to locate it in multiple samples, independently from the offset that is going to be loaded.</p>
<p><img src="/img/ida_python/function_overview.png" alt="Figure 1 - Main function overview">
Figure 1 - Main function overview</p>
<p>To do so, it&rsquo;s possible to open the <strong>text</strong> view and explore the function to collect a few bytes that could be useful for this signature-like phase. I have chosen to get something related to the <strong>strcspn</strong> function that is part of the deobfuscation routine. More precisely, I have chosen to gather 16 bytes (<strong>8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00</strong>).</p>
<p><img src="/img/ida_python/deob_function.png" alt="Figure 2 - Deobfuscation routine">
Figure 2 - Deobfuscation routine</p>
<p>Now we could try to find out if our collected bytes are enough to identify this function. Let’s write a little script that checks this out.</p>
<h2 id="searching-for-the-function-characteristics">Searching for the function characteristics</h2>
<p>The first thing to do is to gather the <strong>.text</strong> segment and then, start to look for our signature. One of the easiest ways to get the segment requested is to iterate over all segments until the <strong>idc.get_segm_name</strong> contains the “<strong>.text”</strong> name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_text_segment</span>(seg_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;.text&#34;</span>):
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>Segments():
</span></span><span style="display:flex;"><span>  start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_start(s)
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_end(s)
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_name(s)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> seg_name:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> start, end
</span></span></code></pre></div><p>Then, we should write a function that is capable to locate our signature:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">patternSearch</span>(address_start, address_end):
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>compiled_binpat_vec_t()
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>parse_binpat_str(
</span></span><span style="display:flex;"><span>        pattern,
</span></span><span style="display:flex;"><span>        address_start,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> res <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[!] Pattern not Found&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        ea <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>bin_search(address_start, address_end, pattern, idaapi<span style="color:#f92672">.</span>BIN_SEARCH_CASE)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[+] Pattern found at: </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(hex(ea)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ea
</span></span></code></pre></div><p>At first glance this code could seem a mess, but it’s easier than expected. Let’s do a deep dive. The parameters <strong>address_start</strong> | <strong>address_end</strong> are related to the text segment, since we are looking for the signature within the whole segment space. To understand the parameters passed to <strong>idaapi.parse_binpat_str</strong>, we could refer to its <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_bytes.html">documentation</a>. However, for interruption its signature is given here:</p>
<blockquote>
<p><strong>parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -&gt; str</strong> (the odd variable could be represented by the out parameter. However it represents a vector of compiled binary patterns, that will be later used with bin_search()). Running those functions together it’s possible to observe few references related to the deobfuscation string used within the <strong>.text</strong> segment, then if we look for those references in IDA we could see that with those few bytes we were able to get all we needed to move forward to collect all the obfuscated parameters.</p>
</blockquote>
<p><img src="https://lh5.googleusercontent.com/4gWjUL1uVbmX1aIjD6h6emg_1IjrTWq7m9I8iUt5oaI7sOwSddMLk9LJj9usj0Zo4OeMkQfAIf8sqBzkwRJwXB_-7_adbxB0V3YZCtk_QS7Ar4ykqA1ovZYgEgDhEAniCKz569KUV5jBsiQw8VoQPSQ" alt="Figure 3 - Code reference of deobfuscation routine">
Figure 3 - Code reference of deobfuscation routine</p>
<h2 id="collecting-parameters">Collecting parameters</h2>
<p>Now we have tested that our script successfully identifies the function within the <strong>.text</strong> segment, however, before proceeding collecting its parameters, it is important to also get information related to its usage. To do so, we could use the returning value from the <strong>bin_search</strong> function and use them as a parameter for <strong>idaapi.get_func()</strong> that will return the addresses where our deobfuscation routine is actually used. As a final step to locate all its references it’s possible to use the function <strong>idautils.XrefsTo</strong> as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">locate_decrypt_function</span>(function_address):
</span></span><span style="display:flex;"><span>    xref_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> xref <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>XrefsTo(function_address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> xref<span style="color:#f92672">.</span>frm <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> xref_list:
</span></span><span style="display:flex;"><span>            xref_list<span style="color:#f92672">.</span>append(xref<span style="color:#f92672">.</span>frm)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(xref_list)
</span></span></code></pre></div><p>Through this method I’ve just created a list that is going to contain all function references. From that list, it is possible to iterate all over the function call and retrieve the obfuscated string.</p>
<p><img src="https://lh6.googleusercontent.com/oeQLy6NE6GfIe-DTLErQgVmQwSBzaCf-EM5DB666-y--7RES2yKOYnQXaTQ8evd24clMhEvmhiKXYQvMUSohzaTWMmgqigSMNu74lr-6czaTyxRp8VL7mR82Ge9JKdXQq6FWMYOMb7dcSmGR91OdN_0" alt="Figure 4 - finding function code and its usage">
Figure 4 - finding function code and its usage</p>
<p>Now, in order to find out the parameters, it’s necessary to observe the pattern used by this sample to understand how to collect the obfuscated string. Observing all the occurrences retrieved, it’s possible to create a function that retrieves all parameters named “offset” with mnemonic push (opcode <strong>68</strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gather_string_offset</span>(xref_address):
</span></span><span style="display:flex;"><span>    function_start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_func_attr(xref_address, FUNCATTR_START)
</span></span><span style="display:flex;"><span>    new_address <span style="color:#f92672">=</span> xref_address
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        prev_address <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>prev_head(new_address)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> prev_address <span style="color:#f92672">&lt;=</span> function_start:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_insn_mnem(prev_address) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;push&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_operand(prev_address,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;offset&#34;</span>: 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> idc<span style="color:#f92672">.</span>get_operand_value(prev_address, <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        new_address <span style="color:#f92672">=</span> prev_address
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[!] Offset not found.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>The function presented here, it’s pretty straightforward. It takes the <strong>fucntion_start</strong> parameters that represents the function block that contains the instruction <strong>call DeobfuscateString</strong> (since the code it’s all written within the main function, <strong>fucntion_start</strong> will be the first instruction in the main. However, in other example our DeobfuscateString function could be part of another subroutine and in that case, the function_start will point to the first instruction of that routine ) Then, from the function the instruction call DeobfuscateString, we start to move backward in order to find out the <strong>offset</strong> parameter that will point to our obfuscated string. It’s worth mentioning that the code <strong>prev_address &lt;= function_start it’s used to avoid going over the main function boundaries</strong> (it doest make any sense to go backward over that line, since our code should be located there).</p>
<p>Now that we have collected all string references related to each call, we are still required to get the whole obfuscated string. In fact, through our code we were able to get the first byte of each string but it’s required to get the whole reference to forward the string to the deobfuscation routine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">retrive_string</span>(offset):
</span></span><span style="display:flex;"><span>    obfuscated_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter)) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>:
</span></span><span style="display:flex;"><span>        obfuscated_string <span style="color:#f92672">+=</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter))
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> obfuscated_string
</span></span></code></pre></div><p>The script here, takes the first string byte and it starts to move forward until a NULL byte it’s located (In this case, the null byte represents the end of our string).</p>
<h2 id="deobfuscation-function">Deobfuscation function</h2>
<p>After retrieving the string, it’s a matter of implementing the deobfuscation routine and applying it to the collected strings. Implementation details are left as an exercise for curious reversers that would like to make it on their own. Since implementation of this specific case it’s actually pointless for a real case scenario, it will be skipped from this article and will be directly implemented within the final IDA-python script.</p>
<h2 id="script-testing">Script Testing</h2>
<p>To run our script it’s possible to go in <em>File &gt; Script</em> <em>file</em>, selecting the proper <em>ida_python</em> script. Testing the script in IDA, it&rsquo;s possible to observe that all obfuscated strings have been correctly deobfuscated and a little comment has been added to the end of each string reference.</p>
<p><img src="https://lh6.googleusercontent.com/CZC2L6z-Ie0G8mb6v0Nutciep3hXx7AerWk-c6vr52u1QyEIicO-E76156SnByknVj8_JtB-m2lZCxuSB_NBst6miGqVh8vcz3zNg81m4raC4QCVV1can-KqGLdLRNp5YH1IzPm9MzhEANTWX-J4XFY" alt="Figure 5 - Variable deobfuscated successfully">
Figure 5 - Variable deobfuscated successfully</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post has been written to illustrate an effective and quite useful technique to locate interesting functions within a binary and to write a custom IDA-python script that is capable of finding all function occurrences. This approach it’s actually very helpful also to avoid configuration dependencies, giving to our script the ability to be shared <strong>without tweaking specific parameters</strong> that could rely on IDA instances.</p>
<h3 id="references">References</h3>
<ul>
<li>Ida-python script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/fSearch.py">fSearch.py</a></li>
<li>source code: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.c">obfuscation.c</a></li>
<li>compiled sample: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.exe">obfuscation.exe</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Extracting DDosia targets from process memory</title>
            <link>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</link>
            <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</guid>
            <description>Introduction This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.
Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.</p>
<p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</p>
<p><a href="https://decoded.avast.io/martinchlumecky/ddosia-project-how-noname05716-is-trying-to-improve-the-efficiency-of-ddos-attacks/">Avast</a> wrote a very detailed article about that project and described thoroughly all changes observed in the last few months. Because of that, before proceeding with this post, If you feel you are missing something, I strongly  recommend that you read their article.</p>
<h2 id="client-setup">Client Setup</h2>
<p>According to the information retrieved from the Telegram channel of DDosia Project, there are a couple of requirements before executing the client. The very first action is to create your id through a dedicated bot that will be used later on for authentication purposes. After that, it&rsquo;s necessary to put the client_id.txt file (generated from DDosia bot) and the executable file in the same folder. If everything has been done properly, it should be possible to observe that authentication process will be done correctly and the client is going to download targets from its server:</p>
<p><img src="/img/ddosia/c_a.png" alt="Figure 1: Client authenticated correctly"></p>
<p>Figure 1: Client authenticated correctly</p>
<h2 id="dynamic-analysis-and-process-memory-inspection">Dynamic analysis and process memory inspection</h2>
<p>Here we are with the fun part. Because of the issues of analyzing GO binaries statically, I preferred to use a dynamic approach supported by Cape sandbox. In fact, executing the client with Cape it was possible to gather behavioral information to speed up our analysis (<a href="https://capesandbox.com/analysis/385183/">ref</a>). Since the executable is going to be used for DDoS attacks, it&rsquo;s easy to expect that most of the functions are related to network routines. One of the most interesting WindowsAPI refers to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>. This is interesting for us, because according to Microsoft documentation, it must be the first function to be used in order to retrieve socket implementation for further network operations:</p>
<blockquote>
<p>The WSAStartup function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling WSAStartup.</p>
</blockquote>
<p>Moreover, starting to monitor network requests with Wireshark, give us additional information about client-server interactions and targets retrieving procedure:</p>
<p><img src="/img/ddosia/network_communication.png" alt="Figure 2 - Request for target list"></p>
<p>Figure 2 - Request for target list</p>
<p>As already mentioned on Avast blogspot, the target list is encrypted and retrieved after the authentication process. However, performing DDoS attacks requires a decryption routine to make targets in cleartext and forward them to a proper procedure. With this insight, it’s possible to open up a debugger and set a breakpoint of WSAStartup and start exploring the process flow from that point.</p>
<p><img src="/img/ddosia/control_flow.png" alt="Figure 3 - Exploring DDosia executable control flow"></p>
<p>Figure 3 - Exploring DDosia executable control flow</p>
<p>Exploring the process execution, it’s possible to observe that <strong>WSAStartup API is called two times before starting the attack.</strong> The first one has been used from the main thread to perform the authentication process on the server side, instead the second call will be done right after retrieving the target file and it will be used from another thread to start the attack phase. Since that information we are looking for has been already downloaded and hopefully decrypted (at the time of the second call) we could explore the process memory trying to identify our target list.</p>
<p><img src="/img/ddosia/cleartext_targets.png" alt="Figure 4 - Target stored in cleartext within process memory">
Figure 4 - Target stored in cleartext within process memory</p>
<p>As we expected, information is actually decrypted right before being used from threads that are in charge to flood the targets. From the cleartext sample, it’s also possible to reconstruct the original json file structure that follow this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;target_id&#34;</span>:<span style="color:#e6db74">&#34;435te3af574b95e395847362&#34;</span>,<span style="color:#f92672">&#34;request_id&#34;</span>:<span style="color:#e6db74">&#34;23cer8c5mmp4434dlad53f2s&#34;</span>,<span style="color:#f92672">&#34;host&#34;</span>:<span style="color:#e6db74">&#34;www.tartuhly.ee&#34;</span>,<span style="color:#f92672">&#34;ip&#34;</span>:<span style="color:#e6db74">&#34;90.190.99.85&#34;</span>,<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;http&#34;</span>,<span style="color:#f92672">&#34;method&#34;</span>:<span style="color:#e6db74">&#34;GET&#34;</span>,<span style="color:#f92672">&#34;port&#34;</span>:<span style="color:#ae81ff">443</span>,<span style="color:#f92672">&#34;use_ssl&#34;</span>:<span style="color:#66d9ef">true</span>,<span style="color:#f92672">&#34;path&#34;</span>:<span style="color:#e6db74">&#34;/otsi/$_1&#34;</span>,<span style="color:#f92672">&#34;body&#34;</span>:{<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>,<span style="color:#f92672">&#34;value&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>},<span style="color:#f92672">&#34;headers&#34;</span>:<span style="color:#66d9ef">null</span>}
</span></span></code></pre></div><p>At this point I have shown all procedures to quickly follow the execution flow until the decryption routine is called. From now on, it&rsquo;s just a matter of looking for those data within process memory and extracting them for your own purpose. It’s worth noting that information won’t be stored decrypted forever, in fact, as the executable keeps running, the json file is actually mangled in a way that is not easy to resemble it properly.</p>
<h2 id="a-little-bit-of-automation">A little bit of automation</h2>
<p>Even if the analysis has been completed and targets are correctly retrieved, I thought that giving a little tool to extract that information would be useful. Instead of doing complex stuff, I wrote two simple scripts called targets.js and recover.py. The purpose of these two files is to allow analysts from different backgrounds to extract those targets, even performing a simple memory dump. Probably there are easier and smarter techniques out there, but it was also a good chance to put in practice DBI, which I have already covered in a previous <a href="https://viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">post</a>.</p>
<ul>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/ConfigurationExtractors/DDosia_Targets/targets.js">target.js</a>: Frida script that aims to get a memory dump after the WSAStartup has been called for the second time (when payloads are in cleartext in memory).</p>
</li>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/ConfigurationExtractors/DDosia_Targets/recover.py">recover.py</a>: it’s a simple python script that retrieves structured information from the files dumped. It’s worth noting that I limited my script to look for structured information, retrieving IP and Hostname (additional improvements are left to user’s needs).</p>
</li>
</ul>
<h2 id="script-testing">Script Testing</h2>
<p>In order to run the mentioned scripts there are two requirements to fulfill:</p>
<ul>
<li>Installing frida-tool (pip install frida-tools).</li>
<li>Create a folder named “dumps” in the same place where you run the target.js file.</li>
</ul>
<p>If all requirements are satisfied it’s just a matter of running those scripts and getting the results. The first step is to run frida.exe, using the targets.js file that contains all the information to dump the process memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>frida.exe &lt;ddosia_client.exe&gt;  -l targets.js
</span></span></code></pre></div><p>If everything has been done correctly (please keep in mind the requirements), you should be able to see a message “[END] Memory dumped correctly” in your console.</p>
<p><img src="/img/ddosia/frida_dump.png" alt="Figure 5 - Dumping process Memory with Frida"></p>
<p>Figure 5 - Dumping process Memory with Frida</p>
<p>Now you can navigate in dumps folder and run the python script using the following command line that is going to forward all dumped file from the current directory to the script that is going to print the result in your console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>python.exe recover.py (Get-Item .\*dump)
</span></span></code></pre></div><p><img src="/img/ddosia/target_extraction.png" alt="Figure 6 - Extracting DDosia targets from dumped files"></p>
<p>Figure 6 - Extracting DDosia targets from dump files</p>
<h2 id="final-notes">Final Notes</h2>
<p>Before concluding, It’s worth mentioning that updates on these scripts and new techniques to dealing with further improvements of DDosia project are not going to be shown, because it represents a topic that I’m not following personally and I’m sure that more authoritative voices will keep track of this threat and its evolution.</p>
<h3 id="references">References:</h3>
<ul>
<li>Binary analyzed: <a href="https://www.virustotal.com/gui/file/726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e">d_windows_amd64.exe</a> | 726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e (sha256) | 19/04/2023</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Dynamic Binary Instrumentation for Malware Analysis</title>
            <link>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</link>
            <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</guid>
            <description>Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</description>
            <content type="html"><![CDATA[<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p>
<p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I’m going to limit this post linking references that would be nice to have to understand everything easily.</p>
<ul>
<li><a href="https://frida.re/docs/javascript-api/">Frida</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">Windows API</a></li>
<li><a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">Ursnif/Gozi</a></li>
</ul>
<h2 id="intercepting-function-calls"><strong>Intercepting function calls</strong></h2>
<p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">ref.</a>) and <strong>VirtualProtect</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p>
<p>So let’s start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p>
<p><img src="https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc" alt="Figure 1 - References to VirtualProtect and call Interceptor"></p>
<p>Figure 1 - References to VirtualProtect and call Interceptor</p>
<p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.  To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with “<strong>MZ</strong>” or “<strong>5d4a</strong>”. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p>
<p><img src="https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk" alt="Figure 2 - Printing VirtualProtect arguments"></p>
<p>Figure 2 - Printing VirtualProtect arguments</p>
<h2 id="retrieving-the-payload"><strong>Retrieving the payload</strong></h2>
<p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p>
<p>As reported by Frida documentation:</p>
<blockquote>
<p>Process.findModuleByAddress(address) returns a <strong><a href="https://frida.re/docs/javascript-api/#module"><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p>
</blockquote>
<p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and  module.base = image base.</p>
<p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which  <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that  return an object with details about the range (memory page) containing address.</p>
<p><img src="https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E" alt=" Figure 3 - Checking for payload address"></p>
<p>Figure 3 - Checking for payload address</p>
<h2 id="dumping-config-file"><strong>Dumping config file</strong></h2>
<p>Now that we have all the information required, it’s time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it’s possible to write it in a file that could be used later on for further manipulation and analysis.</p>
<p><img src="https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U" alt=" Figure 4 - Dumping Ursnif payload"></p>
<p>Figure 4 - Dumping Ursnif payload</p>
<p>It’s worth noting that before proceeding with the configuration extraction phase, it’s necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section  header accordingly. This step is necessary because the payload was extracted directly from memory.</p>
<h2 id="script-testing"><strong>Script Testing</strong></h2>
<p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let’s take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href="https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/">MalwareBazar</a>.</p>
<p>Running the script against this sample with Frida as follow:</p>
<p><code>frida.exe &lt;mal_executable&gt; -l &lt;your_script.js&gt;</code></p>
<p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p>
<p><img src="/img/dbi/extractionWithFrida.png" alt="Figure 5 - Ursnif payload extraction with Frida"></p>
<p>Figure 5 - Ursnif payload extraction with Frida</p>
<p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it’s possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p>
<h2 id="reference">Reference</h2>
<ul>
<li>DBI script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js">mon.py</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Manually unpacking of packed executable</title>
            <link>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</link>
            <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</guid>
            <description>Introduction In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack. However, the goal of this post is to provide a general approach to start reversing code and, in general, packers. Because of that it will be hard to cover all the techniques and strategies that could be applied, but I will try to give the rights hints and the mindset to approach these challenges.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.</p>
<p>I will also try to highlight references to concepts that are almost mandatory to understand when you start doing this activity.</p>
<p>Before to proceed, all files and tools used in this tutorial are available at the following links:</p>
<ul>
<li><a href="https://storage.ey.md/Technology%20Related/Programming%20%26%20Reversing/Tuts4You%20Collection/UnPackMe%20Collection/PE32/WinUpack%200.38.rar">Packed executable</a></li>
<li><a href="http://www.openrce.org/downloads/details/108/OllyDump">OllyDump</a></li>
<li><a href="https://webscene.ir/tools/show/Import-REConstructor-1.6-FINAL">Import Rec</a></li>
</ul>
<p>I expect that most of the people that are approaching this post are already aware of packing techniques and how these are generally implemented.
However, since I strongly dislike to take for granted even this little details, a good reference to dig deeper about this topic is:</p>
<ul>
<li><a href="https://techtalk.pcmatic.com/2017/10/04/debugging-unpacking-malicious-software/">Debugging and Unpacking malicious software</a></li>
</ul>
<p>Let&rsquo;s start to make our hands a little bit dirty :)</p>
<h2 id="loading-exe-file-in-ollydbg">Loading .exe file in OllyDbg</h2>
<p>As soon as you load this file in OllyDbg you&rsquo;ll see an error message related to a corrupted <a href="https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/">PE Header</a>.</p>
<p>However, this error won’t prevent us to debug the application, if we try to run it (F9) the application stopped at 770A01C8 (in my case) and if you follow the execution step-by-step (F8), it will terminate almost immediately with a message box.</p>
<p>So let&rsquo;s step back where the application stopped. On the stack tab, we&rsquo;ll see something like this:</p>
<pre tabindex="0"><code>0018FFF4      | 00401018   | UnPackMe.00401018 |
</code></pre><p>Since it is the only function that is still in the stack, we could be confident that it represents the address of entry point of our PE. This insight is confirmed exploring the PE Header, in fact we saw the ImageBase = 400000 and the AddressOfEntryPoint = 1018 (since it is a <a href="https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/">relative address</a>, we need to sum it with the ImageBase).</p>
<p>According to the information acquired, we could start placing a breakpoint at 00401018 and try to follow the execution step-by-step. After few instructions the stack tab should be similar to this one:</p>
<pre tabindex="0"><code>......
0018FF80   75581222  kernel32.GetProcAddress
0018FF84   755849D7  kernel32.LoadLibraryA
0018FF88   004271B0  UnPackMe.004271B0
0018FF8C   755833CA  RETURN to kernel32.755833CA
0018FF90   7EFDE000
0018FF94  /0018FFD4
0018FF98  |770C9ED2  RETURN to ntdll.770C9ED2
0018FF9C  |7EFDE000
0018FFA0  |7540DB7C
0018FFA4  |00000000
0018FFA8  |00000000
0018FFAC  |7EFDE000
0018FFB0  |00000000
0018FFB4  |00000000
0018FFB8  |00000000
0018FFBC  |0018FFA0
0018FFC0  |00000000
0018FFC4  |FFFFFFFF  End of SEH chain
0018FFC8  |77101ECD  SE handler
0018FFCC  |0253E188
0018FFD0  |00000000
0018FFD4  \0018FFEC
0018FFD8   770C9EA5  RETURN to ntdll.770C9EA5 from ntdll.770C9EAB
0018FFDC   00401018  UnPackMe.00401018
0018FFE0   7EFDE000
0018FFE4   00000000
0018FFE8   00000000
0018FFEC   00000000
0018FFF0   00000000
0018FFF4   00401018  UnPackMe.00401018
0018FFF8   7EFDE000
0018FFFC   00000000
</code></pre><p>As you can see from the stack, we have the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">SEH</a> (structured exception handling) and on the top of it, there are two interesting functions (<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>).</p>
<p><strong>GetProcAddress</strong> retrieves the address of an exported function or variable from the specified dynamic-link library (DLL), instead the function <strong>LoadLibraryA</strong> loads the specified module into the address space of the calling process (note that this module may cause other modules to be loaded).</p>
<p>Since we are trying to follow a repeatable approach, according to the information retrieved so far we could start guessing
(and then proving or refusing) something about the application. As far as we know, the application starts to load some dll (e.g., kernel32.dll) and then from each of them retrieve all functions that are needed for the executable. Then when everything is correctly settled, the application should go back to the OEP (Original Entry Point).</p>
<p><strong>In order to follow this insight its important to understand where these function are called and place a breakpoint there.</strong></p>
<h2 id="examining-a-function-call">Examining a function call</h2>
<p>From here, there are uncountable ways to move forward in order to find the OEP. We could look through the code to understand where GetProcAddress or LoadLibraryA are called for the last time, or we could also find the last function and the last library loaded and from that point move forward to reach the OEP, otherwise we could also look for specific blocks that are commonly used to save the OEP.</p>
<p>However, showing a specific technique is out of scope (as I said, <strong>I would like to give some hints and a mindset to approach to these challenges</strong>),
I&rsquo;m going to explore a little bit more the binary in order to be able to retrieve the OEP, dump the binary and restoring also the IAT (Import Address Table).</p>
<p>After these clarifications we are now ready to proceed with our analysis.</p>
<p>Since we were able to identify GetProcAddress and LoadLibraryA functions on the stack, we could easily move forward until we don&rsquo;t see
that these function are actually called within the UnPackMe address space. In my case, these functions are called from the UnPackMe address space at the following addresses:</p>
<ul>
<li>LoadLibraryA   0049A053</li>
<li>GetProcAddress 0049A06A</li>
</ul>
<p>Now let&rsquo;s go deep a little bit in detail, examining the LoadLibraryA function call and its returning value (the approach is the same for GetProcAddress ).</p>
<p>If you followed the <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">link</a> related to this function you are now aware that LoadLibrabryA take a single parameter that represents the module name. According to the <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">calling convention</a> in x86 this parameters are commonly pushed on the stack, instead the return value is stored in the EAX registry.</p>
<p><img src="/img/winupack/loadLibrary.png" alt="LoadLibraryA details"></p>
<p>From the figure above It is easy to spot that:</p>
<ul>
<li>ESI contains the module name &ldquo;USER32.DLL&rdquo;,</li>
<li>ECX contains the function address of LoadLibraryA.</li>
</ul>
<p>In order to check if EAX contains the module&rsquo;s handler, we do a single step forward after the call ECX instruction. After that instruction we are able to see that EAX contains the handler for the module USER32.</p>
<pre tabindex="0"><code>EAX 74EA0000 OFFSET USER32.#2338
</code></pre><p>Eventually, when the last call to the LoadLibraryA and GetProcAddress are performed the EIP will reach the address <code>0049A06F</code> that contains the <code>RETN</code> instruction that will lead us the actual OEP.</p>
<p><img src="/img/winupack/OEP.png#center" alt="OEP"></p>
<p>Since we were able to go back to the OEP, <strong>we are also confirming that our initial hypothesis was correct</strong>! (Yes I cheated a little bit, since I already knew that it was the right path :) .</p>
<p>From now on, its just a matter of:</p>
<ol>
<li>Dump the executable with Ollydump</li>
<li>Attach to the debugging process with ImportREC</li>
<li>Set the new OEP and search for the IAT.</li>
<li>Fix dump</li>
</ol>
<p>These steps are left as homework for the few people that reached this point :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>To conclude, in this brief post we saw how to manually examine a binary that has been packed, looking for clues, formulate hypothesis and then working to confirm or reject them.</p>
<p>In my experience, reversing isn&rsquo;t going in the middle of the code without an idea, it’s important to follow a method that should be as general as possible. In order to get better, I strongly recommend to practice with other sample trying to apply the same approach we saw here.</p>
<p>In case of doubts, unclear part, or just feedback about this post, feel free to reach me on my mail account.</p>
]]></content>
        </item>
        
    </channel>
</rss>
