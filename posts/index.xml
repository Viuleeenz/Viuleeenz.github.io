<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Security Undisguised</title>
        <link>https://Viuleeenz.github.io/posts/</link>
        <description>Recent content in Posts on Security Undisguised</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
        <lastBuildDate>Tue, 27 Jun 2023 00:00:00 +0000</lastBuildDate>
        <atom:link href="https://Viuleeenz.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Ida-python - Locate function independently from its offset</title>
            <link>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-function-independently-from-its-offset/</link>
            <pubDate>Tue, 27 Jun 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/06/ida-python-locate-function-independently-from-its-offset/</guid>
            <description>Introduction Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.
The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>Analyzing samples statically could be not an easy going taks, especially when you deal with heavily obfuscated or encrypted data. Because of that, it’s useful to find out the decryption/deobfuscation routine and write a little script that makes sense of strings or function names before starting to analyze the whole sample.</p>
<p>The idea behind this technique was inspired by the infinite amount of tweaking I have made to run multiple Ida-python scripts that were heavily machine-setting dependents. The idea is very simple and it’s based on pattern matching as for YARA rules. The scope here is to create a kind of signature for a function that we would like to locate (e.g., deobfuscation routine) and apply its execution to its parameters in order to simplify our analysis <strong>without tweaking specific parameters</strong> making it <strong>independent from the function offset</strong>. I have already got good results experimenting with malware samples (e.g, Qbot) and custom binaries from CTFs as well as other samples that used some sort of obfuscation. Because of that, I decided to create this post to share this approach that could be useful for writing better scripts**.**</p>
<p>Generally speaking, approaching to these sample could be done through multiple perspective (e.g., starting with dynamic analysis and proceeding backwards), however, for the purpose of this blogpost I’m going to take a custom sample written by me, where strings are partially obfuscated with a  custom algorithm and I’m going to show an easy but effective method to write an ida-python script to <strong>locate and deobfuscate variables</strong>.</p>
<h2 id="practical-example">Practical example</h2>
<p>First go first. In order to deobfuscate a piece of code, it&rsquo;s still required to analyze the function that is going to perform this task and replicate its behavior implementing it within our script. For the purpose of this post, this step is out of scope, however, I’m going to directly analyze the assembly code in order to find out how to write the IDA-python script to collect all obfuscated variables to apply the proper routine.</p>
<p>The steps that we are going are pretty much the following:</p>
<ul>
<li>Find out the deobfuscation function;</li>
<li>Create a “signature” to retrieve all its references;</li>
<li>Collect the obfuscated parameters;</li>
<li>Apply the deobfuscation routine;</li>
</ul>
<h2 id="creating-function-signature">Creating function signature</h2>
<p>Since that sample it&rsquo;s actually very easy, finding the proper function it’s not so tricky. In fact, we could see that there is a DWORD that is going to be passed to a function called “<strong>DeobfuscateString</strong>”. However, what really matters here, is to create a signature of this function in order to locate it in multiple samples, independently from the offset that is going to be loaded.</p>
<p><img src="/img/ida_python/function_overview.png" alt="Figure 1 - Main function overview">
Figure 1 - Main function overview</p>
<p>To do so, it&rsquo;s possible to open the <strong>text</strong> view and explore the function to collect a few bytes that could be useful for this signature-like phase. I have chosen to get something related to the <strong>strcspn</strong> function that is part of the deobfuscation routine. More precisely, I have chosen to gather 16 bytes (<strong>8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00</strong>).</p>
<p><img src="/img/ida_python/deob_function.png" alt="Figure 2 - Deobfuscation routine">
Figure 2 - Deobfuscation routine</p>
<p>Now we could try to find out if our collected bytes are enough to identify this function. Let’s write a little script that checks this out.</p>
<h2 id="searching-for-the-function-characteristics">Searching for the function characteristics</h2>
<p>The first thing to do is to gather the <strong>.text</strong> segment and then, start to look for our signature. One of the easiest ways to get the ****segment requested is to iterate over all segments until the <strong>idc.get_segm_name</strong> contains the “<strong>.text”</strong> name:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_text_segment</span>(seg_name<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;.text&#34;</span>):
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> s <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>Segments():
</span></span><span style="display:flex;"><span>  start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_start(s)
</span></span><span style="display:flex;"><span>  end <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_end(s)
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_segm_name(s)
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> name <span style="color:#f92672">==</span> seg_name:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> start, end
</span></span></code></pre></div><p>Then, we should write a function that is capable to locate our signature:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">patternSearch</span>(address_start, address_end):
</span></span><span style="display:flex;"><span>    pattern <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>compiled_binpat_vec_t()
</span></span><span style="display:flex;"><span>    res <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>parse_binpat_str(
</span></span><span style="display:flex;"><span>        pattern,
</span></span><span style="display:flex;"><span>        address_start,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;8D 55 E0 52 8D 45 E4 50 FF 15 CC 20 40 00&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">16</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> res <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[!] Pattern not Found&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>        ea <span style="color:#f92672">=</span> idaapi<span style="color:#f92672">.</span>bin_search(address_start, address_end, pattern, idaapi<span style="color:#f92672">.</span>BIN_SEARCH_CASE)
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">&#34;[+] Pattern found at: </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(hex(ea)))
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> ea
</span></span></code></pre></div><p>At first glance this code could seem a mess, but it’s easier than expected. Let’s do a deep dive. The parameters <strong>address_start</strong> | <strong>address_end</strong> are related to the text segment, since we are looking for the signature within the whole segment space. To understand the parameters passed to <strong>idaapi.parse_binpat_str</strong>, we could refer to its <a href="https://www.hex-rays.com/products/ida/support/idapython_docs/ida_bytes.html">documentation</a>. However, for interruption its signature is given here:</p>
<blockquote>
<p><strong>parse_binpat_str(out, ea, _in, radix, strlits_encoding=0) -&gt; str</strong> (the odd variable could be represented by the out parameter. However it represents a vector of compiled binary patterns, that will be later used with bin_search()). Running those functions together it’s possible to observe few references related to the deobfuscation string used within the <strong>.text</strong> segment, then if we look for those references in IDA we could see that with those few bytes we were able to get all we needed to move forward to collect all the obfuscated parameters.</p>
</blockquote>
<p><img src="https://lh5.googleusercontent.com/4gWjUL1uVbmX1aIjD6h6emg_1IjrTWq7m9I8iUt5oaI7sOwSddMLk9LJj9usj0Zo4OeMkQfAIf8sqBzkwRJwXB_-7_adbxB0V3YZCtk_QS7Ar4ykqA1ovZYgEgDhEAniCKz569KUV5jBsiQw8VoQPSQ" alt="Figure 3 - Code reference of deobfuscation routine">
Figure 3 - Code reference of deobfuscation routine</p>
<h2 id="collecting-parameters">Collecting parameters</h2>
<p>Now we have tested that our script successfully identifies the function within the <strong>.text</strong> segment, however, before proceeding collecting its parameters, it is important to also get information related to its usage. To do so, we could use the returning value from the <strong>bin_search</strong> function and use them as a parameter for <strong>idaapi.get_func()</strong> that will return the addresses where our deobfuscation routine is actually used. As a final step to locate all its references it’s possible to use the function <strong>idautils.XrefsTo</strong> as follow:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">locate_decrypt_function</span>(function_address):
</span></span><span style="display:flex;"><span>    xref_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> xref <span style="color:#f92672">in</span> idautils<span style="color:#f92672">.</span>XrefsTo(function_address):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> xref<span style="color:#f92672">.</span>frm <span style="color:#f92672">not</span> <span style="color:#f92672">in</span> xref_list:
</span></span><span style="display:flex;"><span>            xref_list<span style="color:#f92672">.</span>append(xref<span style="color:#f92672">.</span>frm)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> list(xref_list)
</span></span></code></pre></div><p>Through this method I’ve just created a list that is going to contain all function references. From that list, it is possible to iterate all over the function call and retrieve the obfuscated string.</p>
<p><img src="https://lh6.googleusercontent.com/oeQLy6NE6GfIe-DTLErQgVmQwSBzaCf-EM5DB666-y--7RES2yKOYnQXaTQ8evd24clMhEvmhiKXYQvMUSohzaTWMmgqigSMNu74lr-6czaTyxRp8VL7mR82Ge9JKdXQq6FWMYOMb7dcSmGR91OdN_0" alt="Figure 4 - finding function code and its usage">
Figure 4 - finding function code and its usage</p>
<p>Now, in order to find out the parameters, it’s necessary to observe the pattern used by this sample to understand how to collect the obfuscated string. Observing all the occurrences retrieved, it’s possible to create a function that retrieves all parameters named “offset” with mnemonic push (opcode <strong>68</strong>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gather_string_offset</span>(xref_address):
</span></span><span style="display:flex;"><span>    function_start <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>get_func_attr(xref_address, FUNCATTR_START)
</span></span><span style="display:flex;"><span>    new_address <span style="color:#f92672">=</span> xref_address
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> <span style="color:#66d9ef">True</span>:
</span></span><span style="display:flex;"><span>        prev_address <span style="color:#f92672">=</span> idc<span style="color:#f92672">.</span>prev_head(new_address)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> prev_address <span style="color:#f92672">&lt;=</span> function_start:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_insn_mnem(prev_address) <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;push&#34;</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> idc<span style="color:#f92672">.</span>print_operand(prev_address,<span style="color:#ae81ff">0</span>)<span style="color:#f92672">.</span>split()[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;offset&#34;</span>: 
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> idc<span style="color:#f92672">.</span>get_operand_value(prev_address, <span style="color:#ae81ff">0</span>) 
</span></span><span style="display:flex;"><span>        new_address <span style="color:#f92672">=</span> prev_address
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;[!] Offset not found.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>The function presented here, it’s pretty straightforward. It takes the <strong>fucntion_start</strong> parameters that represents the function block that contains the instruction <strong>call DeobfuscateString</strong> (since the code it’s all written within the main function, <strong>fucntion_start</strong> will be the first instruction in the main. However, in other example our DeobfuscateString function could be part of another subroutine and in that case, the function_start will point to the first instruction of that routine ) Then, from the function the instruction call DeobfuscateString, we start to move backward in order to find out the <strong>offset</strong> parameter that will point to our obfuscated string. It’s worth mentioning that the code prev_address &lt;= function_start it’s used to avoid going over the main function boundaries (it doest make any sense to go backward over that line, since our code should be located there).</p>
<p>Now that we have collected all string references related to each call, we are still required to get the whole obfuscated string. In fact, through our code we were able to get the first byte of each string but it’s required to get the whole reference to forward the string to the deobfuscation routine:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">retrive_string</span>(offset):
</span></span><span style="display:flex;"><span>    obfuscated_string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    counter <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter)) <span style="color:#f92672">!=</span> <span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\x00</span><span style="color:#e6db74">&#34;</span>:
</span></span><span style="display:flex;"><span>        obfuscated_string <span style="color:#f92672">+=</span> chr(idaapi<span style="color:#f92672">.</span>get_byte(offset <span style="color:#f92672">+</span> counter))
</span></span><span style="display:flex;"><span>        counter <span style="color:#f92672">+=</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> obfuscated_string
</span></span></code></pre></div><p>The script here, takes the first string byte and it starts to move forward until a NULL byte it’s located (In this case, the null byte represents the end of our string).</p>
<h2 id="deobfuscation-function">Deobfuscation function</h2>
<p>After retrieving the string, it’s a matter of implementing the deobfuscation routine and applying it to the collected strings. Implementation details are left as an exercise for curious reversers that would like to make it on their own. Since implementation of this specific case it’s actually pointless for a real case scenario, it will be skipped from this article and will be directly implemented within the final IDA-python script.</p>
<h2 id="script-testing">Script Testing</h2>
<p>To run our script  it’s possible to go in <em>File &gt; Script</em> <em>file</em>, selecting the proper <em>ida_python</em> script. Testing the script in IDA, it&rsquo;s possible to observe that all obfuscated strings have been correctly deobfuscated and a little comment has been added to the end of each string reference.</p>
<p><img src="https://lh6.googleusercontent.com/CZC2L6z-Ie0G8mb6v0Nutciep3hXx7AerWk-c6vr52u1QyEIicO-E76156SnByknVj8_JtB-m2lZCxuSB_NBst6miGqVh8vcz3zNg81m4raC4QCVV1can-KqGLdLRNp5YH1IzPm9MzhEANTWX-J4XFY" alt="Figure 5 - Variable deobfuscated successfully">
Figure 5 - Variable deobfuscated successfully</p>
<h2 id="conclusion">Conclusion</h2>
<p>This post has been written to illustrate an effective and quite useful technique to locate interesting functions within a binary and to write a custom IDA-python script that is capable of finding all function occurrences. This approach it’s actually very helpful also to avoid configuration dependencies, giving to our script the ability to be shared without <strong>tweaking specific parameters</strong>  that could rely on IDA instances.</p>
<h3 id="references">References</h3>
<ul>
<li>Ida-python script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/fSearch.py">fSearch.py</a></li>
<li>source code: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.c">obfuscation.c</a></li>
<li>compiled sample: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/IDA-python/function_search/test/obfuscation.exe">obfuscation.exe</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Extracting DDosia targets from process memory</title>
            <link>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</link>
            <pubDate>Mon, 08 May 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/05/extracting-ddosia-targets-from-process-memory/</guid>
            <description>Introduction This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.
Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>This post is part of an analysis that I have carried out during my spare time, motivated by a friend that asked me to have a look at the DDosia project related to the NoName057(16) group. The reason behind this request was caused by DDosia client changes for performing the DDos attacks. Because of that, all procedures used so far for monitoring NoName057(16) activities did not work anymore.</p>
<p>Before starting to reverse DDosia Windows sample, I preferred to gather as much information as possible about NoName057(16) TTPs and a few references to their samples.</p>
<p><a href="https://decoded.avast.io/martinchlumecky/ddosia-project-how-noname05716-is-trying-to-improve-the-efficiency-of-ddos-attacks/">Avast</a> wrote a very detailed article about that project and described thoroughly all changes observed in the last few months. Because of that, before proceeding with this post, If you feel you are missing something, I strongly  recommend that you read their article.</p>
<h2 id="client-setup">Client Setup</h2>
<p>According to the information retrieved from the Telegram channel of DDosia Project, there are a couple of requirements before executing the client. The very first action is to create your id through a dedicated bot that will be used later on for authentication purposes. After that, it&rsquo;s necessary to put the client_id.txt file (generated from DDosia bot) and the executable file in the same folder. If everything has been done properly, it should be possible to observe that authentication process will be done correctly and the client is going to download targets from its server:</p>
<p><img src="/img/ddosia/c_a.png" alt="Figure 1: Client authenticated correctly"></p>
<p>Figure 1: Client authenticated correctly</p>
<h2 id="dynamic-analysis-and-process-memory-inspection">Dynamic analysis and process memory inspection</h2>
<p>Here we are with the fun part. Because of the issues of analyzing GO binaries statically, I preferred to use a dynamic approach supported by Cape sandbox. In fact, executing the client with Cape it was possible to gather behavioral information to speed up our analysis (<a href="https://capesandbox.com/analysis/385183/">ref</a>). Since the executable is going to be used for DDoS attacks, it&rsquo;s easy to expect that most of the functions are related to network routines. One of the most interesting WindowsAPI refers to <a href="https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-wsastartup">WSAStartup</a>. This is interesting for us, because according to Microsoft documentation, it must be the first function to be used in order to retrieve socket implementation for further network operations:</p>
<blockquote>
<p>The WSAStartup function must be the first Windows Sockets function called by an application or DLL. It allows an application or DLL to specify the version of Windows Sockets required and retrieve details of the specific Windows Sockets implementation. The application or DLL can only issue further Windows Sockets functions after successfully calling WSAStartup.</p>
</blockquote>
<p>Moreover, starting to monitor network requests with Wireshark, give us additional information about client-server interactions and targets retrieving procedure:</p>
<p><img src="/img/ddosia/network_communication.png" alt="Figure 2 - Request for target list"></p>
<p>Figure 2 - Request for target list</p>
<p>As already mentioned on Avast blogspot, the target list is encrypted and retrieved after the authentication process. However, performing DDoS attacks requires a decryption routine to make targets in cleartext and forward them to a proper procedure. With this insight, it’s possible to open up a debugger and set a breakpoint of WSAStartup and start exploring the process flow from that point.</p>
<p><img src="/img/ddosia/control_flow.png" alt="Figure 3 - Exploring DDosia executable control flow"></p>
<p>Figure 3 - Exploring DDosia executable control flow</p>
<p>Exploring the process execution, it’s possible to observe that <strong>WSAStartup API is called two times before starting the attack.</strong> The first one has been used from the main thread to perform the authentication process on the server side, instead the second call will be done right after retrieving the target file and it will be used from another thread to start the attack phase. Since that information we are looking for has been already downloaded and hopefully decrypted (at the time of the second call) we could explore the process memory trying to identify our target list.</p>
<p><img src="/img/ddosia/cleartext_targets.png" alt="Figure 4 - Target stored in cleartext within process memory">
Figure 4 - Target stored in cleartext within process memory</p>
<p>As we expected, information is actually decrypted right before being used from threads that are in charge to flood the targets. From the cleartext sample, it’s also possible to reconstruct the original json file structure that follow this format:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-json" data-lang="json"><span style="display:flex;"><span>{<span style="color:#f92672">&#34;target_id&#34;</span>:<span style="color:#e6db74">&#34;435te3af574b95e395847362&#34;</span>,<span style="color:#f92672">&#34;request_id&#34;</span>:<span style="color:#e6db74">&#34;23cer8c5mmp4434dlad53f2s&#34;</span>,<span style="color:#f92672">&#34;host&#34;</span>:<span style="color:#e6db74">&#34;www.tartuhly.ee&#34;</span>,<span style="color:#f92672">&#34;ip&#34;</span>:<span style="color:#e6db74">&#34;90.190.99.85&#34;</span>,<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;http&#34;</span>,<span style="color:#f92672">&#34;method&#34;</span>:<span style="color:#e6db74">&#34;GET&#34;</span>,<span style="color:#f92672">&#34;port&#34;</span>:<span style="color:#ae81ff">443</span>,<span style="color:#f92672">&#34;use_ssl&#34;</span>:<span style="color:#66d9ef">true</span>,<span style="color:#f92672">&#34;path&#34;</span>:<span style="color:#e6db74">&#34;/otsi/$_1&#34;</span>,<span style="color:#f92672">&#34;body&#34;</span>:{<span style="color:#f92672">&#34;type&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>,<span style="color:#f92672">&#34;value&#34;</span>:<span style="color:#e6db74">&#34;&#34;</span>},<span style="color:#f92672">&#34;headers&#34;</span>:<span style="color:#66d9ef">null</span>}
</span></span></code></pre></div><p>At this point I have shown all procedures to quickly follow the execution flow until the decryption routine is called. From now on, it&rsquo;s just a matter of looking for those data within process memory and extracting them for your own purpose. It’s worth noting that information won’t be stored decrypted forever, in fact, as the executable keeps running, the json file is actually mangled in a way that is not easy to resemble it properly.</p>
<h2 id="a-little-bit-of-automation">A little bit of automation</h2>
<p>Even if the analysis has been completed and targets are correctly retrieved, I thought that giving a little tool to extract that information would be useful. Instead of doing complex stuff, I wrote two simple scripts called targets.js and recover.py. The purpose of these two files is to allow analysts from different backgrounds to extract those targets, even performing a simple memory dump. Probably there are easier and smarter techniques out there, but it was also a good chance to put in practice DBI, which I have already covered in a previous <a href="https://viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/">post</a>.</p>
<ul>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/DDosia_Targets/targets.js">target.js</a>: Frida script that aims to get a memory dump after the WSAStartup has been called for the second time (when payloads are in cleartext in memory).</p>
</li>
<li>
<p><a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/DDosia_Targets/recover.py">recover.py</a>: it’s a simple python script that retrieves structured information from the files dumped. It’s worth noting that I limited my script to look for structured information, retrieving IP and Hostname (additional improvements are left to user’s needs).</p>
</li>
</ul>
<h2 id="script-testing">Script Testing</h2>
<p>In order to run the mentioned scripts there are two requirements to fulfill:</p>
<ul>
<li>Installing frida-tool (pip install frida-tools).</li>
<li>Create a folder named “dumps” in the same place where you run the target.js file.</li>
</ul>
<p>If all requirements are satisfied it’s just a matter of running those scripts and getting the results. The first step is to run frida.exe, using the targets.js file that contains all the information to dump the process memory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>frida.exe &lt;ddosia_client.exe&gt;  -l targets.js
</span></span></code></pre></div><p>If everything has been done correctly (please keep in mind the requirements), you should be able to see a message “[END] Memory dumped correctly” in your console.</p>
<p><img src="/img/ddosia/frida_dump.png" alt="Figure 5 - Dumping process Memory with Frida"></p>
<p>Figure 5 - Dumping process Memory with Frida</p>
<p>Now you can navigate in dumps folder and run the python script using the following command line that is going to forward all dumped file from the current directory to the script that is going to print the result in your console:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-powershell" data-lang="powershell"><span style="display:flex;"><span>python.exe recover.py (Get-Item .\*dump)
</span></span></code></pre></div><p><img src="/img/ddosia/target_extraction.png" alt="Figure 6 - Extracting DDosia targets from dumped files"></p>
<p>Figure 6 - Extracting DDosia targets from dump files</p>
<h2 id="final-notes">Final Notes</h2>
<p>Before concluding, It’s worth mentioning that updates on these scripts and new techniques to dealing with further improvements of DDosia project are not going to be shown, because it represents a topic that I’m not following personally and I’m sure that more authoritative voices will keep track of this threat and its evolution.</p>
<h3 id="references">References:</h3>
<ul>
<li>Binary analyzed: <a href="https://www.virustotal.com/gui/file/726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e">d_windows_amd64.exe</a> | 726c2c2b35cb1adbe59039193030f23e552a28226ecf0b175ec5eba9dbcd336e (sha256) | 19/04/2023</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Dynamic Binary Instrumentation for Malware Analysis</title>
            <link>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</link>
            <pubDate>Tue, 14 Mar 2023 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2023/03/dynamic-binary-instrumentation-for-malware-analysis/</guid>
            <description>Introduction Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</description>
            <content type="html"><![CDATA[<h2 id="introduction"><strong>Introduction</strong></h2>
<p>Because of the massive Ursnif campaigns that hit Italy during the last weeks, I was looking for a lightweight method to quickly extract the last infection stage of all collected samples, in order to start further analysis effectively. Due to this, I wrote a little frida script that performs basic Dynamic Binary Instrumentation (DBI) to monitor useful function calls and extracts the Ursnif payload. In this article I am going to briefly discuss this script and the steps needed to start analyzing the resulting binary.</p>
<p>Since I would like to skip redundant topics that are already written all over the internet by people that are Jedi in this field, I’m going to limit this post linking references that would be nice to have to understand everything easily.</p>
<ul>
<li><a href="https://frida.re/docs/javascript-api/">Frida</a></li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">Windows API</a></li>
<li><a href="https://research.checkpoint.com/2020/gozi-the-malware-with-a-thousand-faces/">Ursnif/Gozi</a></li>
</ul>
<h2 id="intercepting-function-calls"><strong>Intercepting function calls</strong></h2>
<p>Most of the time, malware, in order to write memory and run code from the newly allocated space, make use of two functions, such as: <strong>VirtualAlloc</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">ref.</a>) and <strong>VirtualProtect</strong> (<a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotect">ref</a>.). For the purpose of our task, I have chosen the VirtualProtect function, because at the time of its calling, the data (payload) should be already there and it would be easier to analyze.</p>
<p>So let’s start to write out the code that retrieves the <strong>reference</strong> of this function and the interceptor that is going to be used to monitor function calls entry and return. Thanks to Frida, it is possible to directly retrieve function arguments through the variable <strong>args</strong> and check their values. The most important parameter and the one that will be used for our purpose is the <strong>lpAddress</strong> that represents the address space that is involved in this function call.</p>
<p><img src="https://lh3.googleusercontent.com/mra9ne7fbva4FUzxVzhFwTz2QWCiv3W5nM6SvVJT-fMqx2VoyXA-SMrFV_5yx6mVkbWUiLNg9Xxx-c_uEuMRGFrVCGRDp5Cg7cPOOQ9V6lBUu592qFLb4ebOsaVA8ra1ykjAxnhz6F4nbZDjU-RwZqc" alt="Figure 1 - References to VirtualProtect and call Interceptor"></p>
<p>Figure 1 - References to VirtualProtect and call Interceptor</p>
<p>Because of the purpose of the article we are not interested in all <strong>VirtualProtect</strong> calls but we would like to limit our scope to ones that contain a PE header.  To do this, it&rsquo;s possible to verify if <strong>lpAddress</strong> starts with “<strong>MZ</strong>” or “<strong>5d4a</strong>”. If so, we could print out some values in order to check them against the running executable using tools such as <strong>ProcessMonitor</strong> or <strong>ProcessHacker</strong>.</p>
<p><img src="https://lh6.googleusercontent.com/YwJkMozUWoo0bIKWP2QTX_Fr18F3LdGhRu4P2AznmONaPx305jNoDDQRHaAeHQExP96jrpxPjM6QDjxJ2IlFQfaN5oIbAYPImYP-Wq7JalzBHtuPWvcDBptVWvbiInjyAtFl5NUEE9XXvjsV8gE6Vkk" alt="Figure 2 - Printing VirtualProtect arguments"></p>
<p>Figure 2 - Printing VirtualProtect arguments</p>
<h2 id="retrieving-the-payload"><strong>Retrieving the payload</strong></h2>
<p>Now comes the tricky part. If we simply apply this technique to dump the memory that contains the <strong>MZ</strong>, it would be possible for us to also dump the binary that we originally started the infection with. However, analyzing Ursnif code, it&rsquo;s possible to see that it creates a dedicated memory space to write its final stage that is commonly referenced as a DLL. In order to avoid that, it&rsquo;s possible to use a function <em>findModuleByAddress</em> that belongs to the <em>Process</em> object.</p>
<p>As reported by Frida documentation:</p>
<blockquote>
<p>Process.findModuleByAddress(address) returns a <strong><a href="https://frida.re/docs/javascript-api/#module"><code>Module</code></a></strong> whose <em>address</em> or <em>name</em> matches the one specified. In the event that no such module could be found, the <em>find</em>-prefixed functions return <em>null</em> whilst the <em>get</em>-prefixed functions throw an exception.</p>
</blockquote>
<p>In order to avoid exception handling stuff I have preferred to go with find prefix function and then checking if the Module returned is equal to null. Otherwise, we would have an existing module object and  module.base = image base.</p>
<p>Now, as a final step before moving on and dumping the actual payload, it&rsquo;s necessary to retrieve the page size to which  <strong>lpAddress</strong> belongs. That information could be retrieved using the findRangeByAddress that  return an object with details about the range (memory page) containing address.</p>
<p><img src="https://lh4.googleusercontent.com/disgHE5VRs6Ob1F0hCt2bKCsfuc3AsxUFViJkqkf_EfYYCmpsiUOILazwCz6asBUsj3paJZ5Libw9N0dYYGSzY60PQRmukGzwFTDfkONM_V2McgqX69kVVlUzrRksfiuM48oDS_GzsPzMQA9gz_GN5E" alt=" Figure 3 - Checking for payload address"></p>
<p>Figure 3 - Checking for payload address</p>
<h2 id="dumping-config-file"><strong>Dumping config file</strong></h2>
<p>Now that we have all the information required, it’s time to dump the actual Ursnif payload. In order to do this, it&rsquo;s possible to read the page related to <strong>lpAddress</strong> using the <em>readByteArray</em> using the <strong>module.size</strong>. Once the information has been stored, it’s possible to write it in a file that could be used later on for further manipulation and analysis.</p>
<p><img src="https://lh3.googleusercontent.com/ju4MZv16hQgyeT6Si6wn_Y6-ble6sl4Oq8L2Jx93vCt3OpxmJBjDvdRCDD9yDVsUIRueQSPksuWVEMsxNUppGE1DsNM5F_PGdanWV4_wqOSuNpUnst2UdLT7emcpaaJMYuLigwBKRvHzuTyY86E3q2U" alt=" Figure 4 - Dumping Ursnif payload"></p>
<p>Figure 4 - Dumping Ursnif payload</p>
<p>It’s worth noting that before proceeding with the configuration extraction phase, it’s necessary to modify <code>Raw addresses</code> and <code>Virtual Addresses</code> of each section  header accordingly. This step is necessary because the payload was extracted directly from memory.</p>
<h2 id="script-testing"><strong>Script Testing</strong></h2>
<p>Now that we have completed our script it&rsquo;s time for testing with a real case! Let’s take one of the recent samples delivered by the TA and see if it works. For this example I have chosen a publicly available sample on <a href="https://bazaar.abuse.ch/sample/83ece9c5d6ffe0e99276becec96bc1c181a731ebd2fb95eaef329d2fbbec7271/">MalwareBazar</a>.</p>
<p>Running the script against this sample with Frida as follow:</p>
<p><code>frida.exe &lt;mal_executable&gt; -l &lt;your_script.js&gt;</code></p>
<p>It will produce a file called <strong>0x2cf0000_mz.bin</strong> (it may vary from the memory address allocation on your machine).</p>
<p><img src="/img/dbi/extractionWithFrida.png" alt="Figure 5 - Ursnif payload extraction with Frida"></p>
<p>Figure 5 - Ursnif payload extraction with Frida</p>
<p>If we open this file with PE-Bear, what should alert us, is the import table that contains unresolved information. This happens, because our code has been extracted directly from memory and before proceeding with our analysis it is necessary to map the raw sections addresses with their virtual counterparts (for brevity I have prepared a script that is going to perform these steps automatically). After having settled the addresses properly, it’s possible to proceed with configuration extraction through a custom script (that is out of the scope for this post).</p>
<h2 id="reference">Reference</h2>
<ul>
<li>DBI script: <a href="https://github.com/Viuleeenz/Reversing_Notes/blob/main/DynamicBinaryInstrumentation/mon.js">mon.py</a></li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Manually unpacking of packed executable</title>
            <link>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</link>
            <pubDate>Thu, 02 Sep 2021 00:00:00 +0000</pubDate>
            
            <guid>https://Viuleeenz.github.io/posts/2021/09/manually-unpacking-of-packed-executable/</guid>
            <description>Introduction In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack. However, the goal of this post is to provide a general approach to start reversing code and, in general, packers. Because of that it will be hard to cover all the techniques and strategies that could be applied, but I will try to give the rights hints and the mindset to approach these challenges.</description>
            <content type="html"><![CDATA[<h2 id="introduction">Introduction</h2>
<p>In this post, I will show how to manually unpack a simple executable that has been packed with WinUPack.
However, the goal of this post is to provide a general approach to start reversing code and, in general, packers.
Because of that it will be hard to cover all the techniques and strategies that could be applied,
but I will try to give the rights hints and the mindset to approach these challenges.</p>
<p>I will also try to highlight references to concepts that are almost mandatory to understand when you start doing this activity.</p>
<p>Before to proceed, all files and tools used in this tutorial are available at the following links:</p>
<ul>
<li><a href="https://storage.ey.md/Technology%20Related/Programming%20%26%20Reversing/Tuts4You%20Collection/UnPackMe%20Collection/PE32/WinUpack%200.38.rar">Packed executable</a></li>
<li><a href="http://www.openrce.org/downloads/details/108/OllyDump">OllyDump</a></li>
<li><a href="https://webscene.ir/tools/show/Import-REConstructor-1.6-FINAL">Import Rec</a></li>
</ul>
<p>I expect that most of the people that are approaching this post are already aware of packing techniques and how these are generally implemented.
However, since I strongly dislike to take for granted even this little details, a good reference to dig deeper about this topic is:</p>
<ul>
<li><a href="https://techtalk.pcmatic.com/2017/10/04/debugging-unpacking-malicious-software/">Debugging and Unpacking malicious software</a></li>
</ul>
<p>Let&rsquo;s start to make our hands a little bit dirty :)</p>
<h2 id="loading-exe-file-in-ollydbg">Loading .exe file in OllyDbg</h2>
<p>As soon as you load this file in OllyDbg you&rsquo;ll see an error message related to a corrupted <a href="https://tech-zealots.com/malware-analysis/pe-portable-executable-structure-malware-analysis-part-2/">PE Header</a>.</p>
<p>However, this error won’t prevent us to debug the application, if we try to run it (F9) the application stopped at 770A01C8 (in my case) and if you follow the execution step-by-step (F8), it will terminate almost immediately with a message box.</p>
<p>So let&rsquo;s step back where the application stopped. On the stack tab, we&rsquo;ll see something like this:</p>
<pre tabindex="0"><code>0018FFF4      | 00401018   | UnPackMe.00401018 |
</code></pre><p>Since it is the only function that is still in the stack, we could be confident that it represents the address of entry point of our PE. This insight is confirmed exploring the PE Header, in fact we saw the ImageBase = 400000 and the AddressOfEntryPoint = 1018 (since it is a <a href="https://tech-zealots.com/malware-analysis/understanding-concepts-of-va-rva-and-offset/">relative address</a>, we need to sum it with the ImageBase).</p>
<p>According to the information acquired, we could start placing a breakpoint at 00401018 and try to follow the execution step-by-step. After few instructions the stack tab should be similar to this one:</p>
<pre tabindex="0"><code>......
0018FF80   75581222  kernel32.GetProcAddress
0018FF84   755849D7  kernel32.LoadLibraryA
0018FF88   004271B0  UnPackMe.004271B0
0018FF8C   755833CA  RETURN to kernel32.755833CA
0018FF90   7EFDE000
0018FF94  /0018FFD4
0018FF98  |770C9ED2  RETURN to ntdll.770C9ED2
0018FF9C  |7EFDE000
0018FFA0  |7540DB7C
0018FFA4  |00000000
0018FFA8  |00000000
0018FFAC  |7EFDE000
0018FFB0  |00000000
0018FFB4  |00000000
0018FFB8  |00000000
0018FFBC  |0018FFA0
0018FFC0  |00000000
0018FFC4  |FFFFFFFF  End of SEH chain
0018FFC8  |77101ECD  SE handler
0018FFCC  |0253E188
0018FFD0  |00000000
0018FFD4  \0018FFEC
0018FFD8   770C9EA5  RETURN to ntdll.770C9EA5 from ntdll.770C9EAB
0018FFDC   00401018  UnPackMe.00401018
0018FFE0   7EFDE000
0018FFE4   00000000
0018FFE8   00000000
0018FFEC   00000000
0018FFF0   00000000
0018FFF4   00401018  UnPackMe.00401018
0018FFF8   7EFDE000
0018FFFC   00000000
</code></pre><p>As you can see from the stack, we have the <a href="https://docs.microsoft.com/en-us/windows/win32/debug/structured-exception-handling">SEH</a> (structured exception handling) and on the top of it, there are two interesting functions (<a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-getprocaddress">GetProcAddress</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a>).</p>
<p><strong>GetProcAddress</strong> retrieves the address of an exported function or variable from the specified dynamic-link library (DLL), instead the function <strong>LoadLibraryA</strong> loads the specified module into the address space of the calling process (note that this module may cause other modules to be loaded).</p>
<p>Since we are trying to follow a repeatable approach, according to the information retrieved so far we could start guessing
(and then proving or refusing) something about the application. As far as we know, the application starts to load some dll (e.g., kernel32.dll) and then from each of them retrieve all functions that are needed for the executable. Then when everything is correctly settled, the application should go back to the OEP (Original Entry Point).</p>
<p><strong>In order to follow this insight its important to understand where these function are called and place a breakpoint there.</strong></p>
<h2 id="examining-a-function-call">Examining a function call</h2>
<p>From here, there are uncountable ways to move forward in order to find the OEP. We could look through the code to understand where GetProcAddress or LoadLibraryA are called for the last time, or we could also find the last function and the last library loaded and from that point move forward to reach the OEP, otherwise we could also look for specific blocks that are commonly used to save the OEP.</p>
<p>However, showing a specific technique is out of scope (as I said, <strong>I would like to give some hints and a mindset to approach to these challenges</strong>),
I&rsquo;m going to explore a little bit more the binary in order to be able to retrieve the OEP, dump the binary and restoring also the IAT (Import Address Table).</p>
<p>After these clarifications we are now ready to proceed with our analysis.</p>
<p>Since we were able to identify GetProcAddress and LoadLibraryA functions on the stack, we could easily move forward until we don&rsquo;t see
that these function are actually called within the UnPackMe address space. In my case, these functions are called from the UnPackMe address space at the following addresses:</p>
<ul>
<li>LoadLibraryA   0049A053</li>
<li>GetProcAddress 0049A06A</li>
</ul>
<p>Now let&rsquo;s go deep a little bit in detail, examining the LoadLibraryA function call and its returning value (the approach is the same for GetProcAddress ).</p>
<p>If you followed the <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">link</a> related to this function you are now aware that LoadLibrabryA take a single parameter that represents the module name. According to the <a href="https://en.wikibooks.org/wiki/X86_Disassembly/Calling_Conventions">calling convention</a> in x86 this parameters are commonly pushed on the stack, instead the return value is stored in the EAX registry.</p>
<p><img src="/img/winupack/loadLibrary.png" alt="LoadLibraryA details"></p>
<p>From the figure above It is easy to spot that:</p>
<ul>
<li>ESI contains the module name &ldquo;USER32.DLL&rdquo;,</li>
<li>ECX contains the function address of LoadLibraryA.</li>
</ul>
<p>In order to check if EAX contains the module&rsquo;s handler, we do a single step forward after the call ECX instruction. After that instruction we are able to see that EAX contains the handler for the module USER32.</p>
<pre tabindex="0"><code>EAX 74EA0000 OFFSET USER32.#2338
</code></pre><p>Eventually, when the last call to the LoadLibraryA and GetProcAddress are performed the EIP will reach the address <code>0049A06F</code> that contains the <code>RETN</code> instruction that will lead us the actual OEP.</p>
<p><img src="/img/winupack/OEP.png#center" alt="OEP"></p>
<p>Since we were able to go back to the OEP, <strong>we are also confirming that our initial hypothesis was correct</strong>! (Yes I cheated a little bit, since I already knew that it was the right path :) .</p>
<p>From now on, its just a matter of:</p>
<ol>
<li>Dump the executable with Ollydump</li>
<li>Attach to the debugging process with ImportREC</li>
<li>Set the new OEP and search for the IAT.</li>
<li>Fix dump</li>
</ol>
<p>These steps are left as homework for the few people that reached this point :)</p>
<h2 id="conclusion">Conclusion</h2>
<p>To conclude, in this brief post we saw how to manually examine a binary that has been packed, looking for clues, formulate hypothesis and then working to confirm or reject them.</p>
<p>In my experience, reversing isn&rsquo;t going in the middle of the code without an idea, it’s important to follow a method that should be as general as possible. In order to get better, I strongly recommend to practice with other sample trying to apply the same approach we saw here.</p>
<p>In case of doubts, unclear part, or just feedback about this post, feel free to reach me on my mail account.</p>
]]></content>
        </item>
        
    </channel>
</rss>
